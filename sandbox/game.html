<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dodge Blocks - Jogo Simples (HTML/CSS/JS)</title>
  <style>
    /* Reset simples */
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{display:flex;align-items:center;justify-content:center;background:#0b1020;color:#fff;font-family:Inter,system-ui,Arial,sans-serif}

    /* Container do jogo */
    .game-wrap{width:420px;padding:16px;background:linear-gradient(180deg,#0f1724 0%, #081226 100%);border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,.6)}

    header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
    header h1{font-size:18px;letter-spacing:0.4px}
    .hud{font-size:14px;opacity:.9}

    /* Canvas responsivo (fixo) */
    canvas{display:block;background:#071028;border-radius:8px;outline:3px solid rgba(255,255,255,0.03)}

    footer{margin-top:10px;font-size:13px;opacity:.85}

    /* Pequenos estilos para botões */
    .controls{display:flex;gap:8px}
    button{background:#1c7ed6;border:none;color:white;padding:6px 10px;border-radius:8px;cursor:pointer;font-weight:600}
    button.secondary{background:#2b2f42}
    small{display:block;color:#9fb0d0;margin-top:6px}

    /* Mensagem de fim de jogo */
    .overlay{position:relative}
    .game-over{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(3,6,12,0.7);padding:18px;border-radius:10px;text-align:center;min-width:260px;display:none}
    .game-over.show{display:block}
  </style>
</head>
<body>
  <div class="game-wrap">
    <header>
      <h1>Dodge Blocks</h1>
      <div class="hud">
        Score: <span id="score">0</span>
      </div>
    </header>

    <div class="overlay">
      <canvas id="game" width="400" height="600"></canvas>
      <div id="gameOver" class="game-over">
        <h2 id="goTitle">Game Over</h2>
        <p>Score final: <strong id="finalScore">0</strong></p>
        <div style="margin-top:10px">
          <button id="restartBtn">Reiniciar (R)</button>
          <button id="easyBtn" class="secondary">Fácil</button>
          <button id="hardBtn" class="secondary">Difícil</button>
        </div>
        <small>Use ← → ou A D para mover. Pressione R para reiniciar.</small>
      </div>
    </div>

    <footer>
      <div class="controls">
        <button id="startBtn">Iniciar</button>
        <button id="pauseBtn" class="secondary">Pausar</button>
      </div>
      <small>Objetivo: sobreviver o máximo que conseguir evitando os blocos que caem.</small>
    </footer>
  </div>

  <script>
    // Dodge Blocks - jogo simples em um único arquivo
    // Autor: ChatGPT (exemplo didático)

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const gameOverEl = document.getElementById('gameOver');
    const finalScoreEl = document.getElementById('finalScore');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const restartBtn = document.getElementById('restartBtn');
    const easyBtn = document.getElementById('easyBtn');
    const hardBtn = document.getElementById('hardBtn');

    const W = canvas.width, H = canvas.height;

    let keys = {};
    let player, obstacles, lastTime, spawnTimer, score, running, difficulty;

    function reset(){
      player = {x: W/2 - 18, y: H - 60, w:36, h:36, speed: 260};
      obstacles = [];
      spawnTimer = 0;
      score = 0;
      lastTime = null;
      running = false;
      difficulty = 'normal'; // normal by default
      updateHUD();
      hideGameOver();
      clearCanvas();
      drawPlayer();
    }

    function setDifficulty(level){
      difficulty = level;
      if(level === 'easy') player.speed = 300;
      else if(level === 'hard') player.speed = 200;
      else player.speed = 260;
    }

    function start(){
      if(!running){
        running = true;
        lastTime = performance.now();
        requestAnimationFrame(loop);
      }
    }

    function pause(){
      running = false;
    }

    function gameOver(){
      running = false;
      finalScoreEl.textContent = Math.floor(score);
      showGameOver();
    }

    function showGameOver(){
      gameOverEl.classList.add('show');
    }

    function hideGameOver(){
      gameOverEl.classList.remove('show');
    }

    function spawnObstacle(){
      const minW = 20, maxW = 90;
      const w = Math.random() * (maxW - minW) + minW;
      const x = Math.random() * (W - w);
      let baseSpeed = 90 + Math.random() * 140; // base fall speed
      if(difficulty === 'easy') baseSpeed *= 0.8;
      if(difficulty === 'hard') baseSpeed *= 1.35;
      obstacles.push({x, y:-20, w, h:20, vy: baseSpeed});
    }

    function update(dt){
      // spawn logic
      spawnTimer += dt;
      const spawnInterval = difficulty === 'hard' ? 0.55 : difficulty === 'easy' ? 1.0 : 0.8;
      if(spawnTimer > spawnInterval){
        spawnObstacle();
        spawnTimer = 0;
      }

      // player movement
      if(keys['ArrowLeft'] || keys['a']) player.x -= player.speed * dt;
      if(keys['ArrowRight'] || keys['d']) player.x += player.speed * dt;
      // clamp
      if(player.x < 0) player.x = 0;
      if(player.x + player.w > W) player.x = W - player.w;

      // obstacles
      for(let i = obstacles.length-1; i >=0; i--){
        const o = obstacles[i];
        o.y += o.vy * dt;
        // remove off-screen
        if(o.y > H + 50) obstacles.splice(i,1);
        // collision
        if(rectIntersect(o, player)){
          gameOver();
        }
      }

      // score increases with time and with number of obstacles dodged
      score += dt * 10;
      updateHUD();
    }

    function rectIntersect(a,b){
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    function draw(){
      clearCanvas();
      // background grid
      drawGrid();
      // player
      drawPlayer();
      // obstacles
      obstacles.forEach(o => drawObstacle(o));
    }

    function drawGrid(){
      ctx.save();
      ctx.globalAlpha = 0.06;
      for(let i=0;i<W;i+=20){ ctx.fillStyle = '#fff'; ctx.fillRect(i,0,1,H); }
      for(let j=0;j<H;j+=20){ ctx.fillStyle = '#fff'; ctx.fillRect(0,j,W,1); }
      ctx.restore();
    }

    function drawPlayer(){
      ctx.save();
      // player shadow
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(player.x+2, player.y+6, player.w, player.h);
      // player body
      ctx.fillStyle = '#52b788';
      roundRect(ctx, player.x, player.y, player.w, player.h, 6, true, false);
      // eyes (decoration)
      ctx.fillStyle = '#072b1f';
      ctx.fillRect(player.x + 8, player.y + 10, 6, 6);
      ctx.fillRect(player.x + player.w - 14, player.y + 10, 6, 6);
      ctx.restore();
    }

    function drawObstacle(o){
      ctx.save();
      ctx.fillStyle = '#ef476f';
      roundRect(ctx, o.x, o.y, o.w, o.h, 4, true, false);
      ctx.restore();
    }

    function clearCanvas(){
      ctx.clearRect(0,0,W,H);
    }

    function updateHUD(){
      scoreEl.textContent = Math.floor(score);
    }

    function loop(now){
      if(!running) return;
      const dt = (now - lastTime) / 1000;
      lastTime = now;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    // small utility to draw rounded rectangles
    function roundRect(ctx,x,y,w,h,r,fill,stroke){
      if(typeof r === 'undefined') r=5;
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
      if(fill) ctx.fill();
      if(stroke) ctx.stroke();
    }

    // Input handling
    window.addEventListener('keydown',e=>{
      keys[e.key] = true;
      if(e.key === 'r' || e.key === 'R') restart();
      if(e.key === ' '){ // space to pause
        if(running) pause(); else start();
      }
    });
    window.addEventListener('keyup',e=>{ keys[e.key] = false; });

    // Buttons
    startBtn.addEventListener('click', ()=>{ start(); hideGameOver(); });
    pauseBtn.addEventListener('click', ()=>{ pause(); });
    restartBtn.addEventListener('click', ()=>{ restart(); });
    easyBtn.addEventListener('click', ()=>{ setDifficulty('easy'); restart(); });
    hardBtn.addEventListener('click', ()=>{ setDifficulty('hard'); restart(); });

    function restart(){
      reset();
      start();
    }

    // Inicializa
    reset();
  </script>
</body>
</html>
